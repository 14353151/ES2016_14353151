### DeadLock

#### 1、实验题目：了解死锁的原理以及产生的原因

#### 2分析死锁产生原因

​	 死锁就是当一个线程A申请调用资源B时，而资源B又被线程C占有，这时A就要等待C运行完来释放B，一般情况是没有问题的，但是如果此时线程C为了运行玩又需要线程A的已占有资源D，则此时C又要等待线程A运行完，此时就发生了一个最基本的死锁。上述的死锁是最基本的情况，还有多线程死锁的情况。

​	死锁产生的4个必要条件（死锁了必定出现这4个条件，但是出现这4个条件不一定死锁）：

（1） 互斥条件：一个资源每次只能被一个进程使用。
（2） 占有且等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放。
（3）不可强行占有:进程已获得的资源，在末使用完之前，不能强行剥夺，也就是没有外力将其剥夺。
（4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系，其实出现了环，无论是两个线程还是多个线程都很会出现这种情况。

#### 3、本次实验分析

​	本次实验是两个线程之间的死锁。分析Deadlock代码：

​	它先创建了一个线程t，这个线程在被启用的时候，它进入了队列中排队，等它被调用时，会运行run函数，这样系统执行`b.methodB(a) `函数，这样就直接占有了类a。在系统创建线程t后，系统进入一个while循环，在这个循环结束时，之前t线程可能运行完，也可能没有执行完，此时系统调用了函数`a.method(b)` ，这个线程要申请类b，一般情况下，有可能主线程会先执行`a.method(b)` ，又有可能线程t 排完队了先执行`b.method(a)` ，这两种情况都会不会导致死锁，因为它们都会释放资源。

​	但是如果它们两个线程同时执行或者几乎同时执行，由于两个函数都定义为synchronized，所以不可能同时执行，这样就要先等一个线程执行完再到另一个线程执行，这样就好导致死锁了，因为主线程要执行`a.method(b)` 必须申请b资源，就要等线程t运行完`b.method(a)` 后释放资源b， 同理t要运行完，也等主线程释放资源a，这样就必定导致死锁了。

#### 4、实验结果截图







 ![deadlock](C:\Users\davidli\Desktop\deadlock.png)